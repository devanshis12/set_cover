'''
Hill Climbing Algorithm (LS1)

This file implements a hill climbing algorithm to solve the Minimum Set Cover problem.
The algorithm starts with a greedy approximation solution and iteratively improves it by:
1. Trying to remove redundant sets while maintaining coverage
2. Swapping sets to explore new solution spaces

Usage:
  python3 hillclimbing.py -inst <filename> -alg LS1 -time <cutoff in seconds> -seed <random seed>

Arguments:
  -inst: Path to the instance file
  -alg: Algorithm to use (LS1 for this file)
  -time: Cutoff time in seconds
  -seed: Random seed for reproducibility

Output:
  Creates two files in the 'output' directory:
  - <instance>_LS1_<cutoff>_<seed>.sol: Solution file with the best solution found
  - <instance>_LS1_<cutoff>_<seed>.trace: Trace file with timestamps and solution qualities
'''


import argparse
import random
import time
import os
import copy


def approx_msc(U, S):
    '''
    input: U = {x_1, x_2, ..., x_n}: set of n elements
           S = {S_1, S_2, ..., S_m} where S_i is a subset of U: list of sets
    output: C is a subset of S such that C covers all elements in U: list of sets
    '''
    C = []                # initialize the cover as empty
    uncovered = set(U)    # all elements in U are initially uncovered
    while uncovered:      # while there are still uncovered elements
        best_subset = max(S, key=lambda s: len(uncovered & s))  # find the subset that covers the most uncovered elements
        C.append(best_subset)     # add it to the cover
        uncovered -= best_subset  # remove the covered elements from the uncovered set

    # below is optional
    def needs_pruning(s, C):
        # check if the set s is necessary in the cover
        # a set is necessary if removing it would leave some elements uncovered
        remaining = set().union(*(c for c in C if c != s))
        return s <= remaining  # if s is a subset of the remaining sets, it is not necessary
    
    # prune the cover to remove any redundant sets
    pruned = []
    for s in C:
        temp_cover = pruned + [x for x in C if x != s]
        if not needs_pruning(s, temp_cover):
            pruned.append(s)
    C = pruned  # update the cover with the pruned sets

    return C               # return the cover

def parse_instance(filepath):
    '''
    input: filepath: path to the file containing the instance
    output: U: set of elements
            S: list of subsets
            subset_indices: mapping from subsets to their original indices
    '''
    with open(filepath, 'r') as f:
        lines = f.readlines()
    
    n, m = map(int, lines[0].split())
    S = []
    subset_indices = {}  # To keep track of original indices
    
    for i, line in enumerate(lines[1:], 1):
        parts = list(map(int, line.split()))
        S_i = set(parts[1:])
        S.append(S_i)
        subset_indices[frozenset(S_i)] = i  # Use frozenset as dictionary key
    
    U = set(range(1, n + 1))
    return U, S, subset_indices

def is_solution_feasible(solution, U):
    '''
    Check if a solution covers all elements
    '''
    covered = set().union(*solution) if solution else set()
    return covered == U

def hill_climbing(U, S, subset_indices, initial_solution=None, max_iterations=1000, seed=None, cutoff_time=None):
    '''
    Hill Climbing algorithm for Minimum Set Cover
    input: U = {x_1, x_2, ..., x_n}: set of n elements
           S = {S_1, S_2, ..., S_m} where S_i is a subset of U: list of sets
           subset_indices: mapping from subsets to their original indices
           initial_solution: optional initial solution (list of sets)
           max_iterations: maximum number of iterations
           seed: random seed for reproducibility
           cutoff_time: maximum running time in seconds
    output: best_solution: list of sets representing the best solution found
            solution_indices: list of indices of the selected subsets
            trace: list of (timestamp, solution quality) pairs
    '''
    if seed is not None:
        random.seed(seed)
    
    # Start with a solution (either provided or generated by approx_msc)
    current_solution = initial_solution if initial_solution is not None else approx_msc(U, S)
    
    # Keep track of the best solution found
    best_solution = copy.deepcopy(current_solution)
    best_cost = len(best_solution)
    
    # For writing the trace file
    trace = [(0.0, best_cost)]
    start_time = time.time()
    
    # Main Hill Climbing loop
    iteration = 0
    while iteration < max_iterations:
        # Check if we've exceeded the cutoff time
        if cutoff_time is not None and time.time() - start_time >= cutoff_time:
            break
            
        # Try to improve the solution
        improved = False
        
        # Try removing a subset (if it keeps the solution feasible)
        for i, subset in enumerate(current_solution):
            # Create a new solution without this subset
            new_solution = current_solution[:i] + current_solution[i+1:]
            
            # Check if the new solution is feasible
            if is_solution_feasible(new_solution, U):
                # If it's feasible and better, update the current solution
                current_solution = new_solution
                
                # Check if it's also the best solution found so far
                if len(current_solution) < best_cost:
                    best_solution = copy.deepcopy(current_solution)
                    best_cost = len(best_solution)
                    elapsed = time.time() - start_time
                    trace.append((elapsed, best_cost))
                
                improved = True
                break
        
        # Try swapping a subset with another (if it keeps the solution feasible)
        if not improved:
            for i, subset_in in enumerate(current_solution):
                for subset_out in S:
                    if subset_out in current_solution:
                        continue  # Skip subsets already in the solution
                    
                    # Create a new solution by swapping
                    new_solution = current_solution[:i] + [subset_out] + current_solution[i+1:]
                    
                    # Check if the new solution is feasible
                    if is_solution_feasible(new_solution, U):
                        # If it's feasible and not worse, update the current solution
                        current_solution = new_solution
                        improved = True
                        break
                
                if improved:
                    break
        
        # If no improvement was possible, we've reached a local optimum
        if not improved:
            break
        
        iteration += 1
    
    # Convert the solution to original indices
    solution_indices = [subset_indices[frozenset(s)] for s in best_solution]
    
    return best_solution, solution_indices, trace


def write_output(instance, method, cutoff, seed, solution, trace):
    '''
    Write output files
    '''
    # Extract the base name of the instance file
    instance_name = os.path.splitext(os.path.basename(instance))[0]
    
    # Create output directory if it doesn't exist
    output_dir = "output"
    os.makedirs(output_dir, exist_ok=True)
    
    # Write solution file
    solution_file = f"{output_dir}/{instance_name}_{method}_{cutoff}"
    if seed is not None:
        solution_file += f"_{seed}"
    solution_file += ".sol"
    
    with open(solution_file, 'w') as f:
        f.write(f"{len(solution)}\n")
        f.write(" ".join(map(str, solution)) + "\n")
    
    # Write trace file
    trace_file = f"{output_dir}/{instance_name}_{method}_{cutoff}"
    if seed is not None:
        trace_file += f"_{seed}"
    trace_file += ".trace"
    
    with open(trace_file, 'w') as f:
        for time_stamp, quality in trace:
            f.write(f"{time_stamp:.2f} {quality}\n")


def read_input(filename):
    with open(filename, 'r') as f:
        lines = f.readlines()
    
    n, m = map(int, lines[0].split())
    S = []
    subset_indices = {}  # To track original indices

    for i, line in enumerate(lines[1:], 1):
        parts = list(map(int, line.split()))
        S_i = set(parts[1:])
        S.append(S_i)
        subset_indices[frozenset(S_i)] = i  # Use frozenset as dictionary key
    
    U = set(range(1, n + 1))
    return U, S, subset_indices


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-inst', required=True, help='Path to the instance file')
    parser.add_argument('-alg', required=True, choices=['BnB', 'Approx', 'LS1', 'LS2'], help='Algorithm to use')
    parser.add_argument('-time', type=int, required=True, help='Cutoff time in seconds')
    parser.add_argument('-seed', type=int, required=False, help='Random seed')
    
    args = parser.parse_args()
    
    # Read the instance
    U, S, subset_indices = parse_instance(args.inst)
    
    # Run the appropriate algorithm
    if args.alg == 'BnB':
        # Run branch and bound
        pass
    elif args.alg == 'Approx':
        # Run approximation algorithm
        solution = approx_msc(U, S)
        solution_indices = [subset_indices[frozenset(s)] for s in solution]
        trace = [(0.0, len(solution))]  # Only initial solution
        write_output(args.inst, args.alg, args.time, None, solution_indices, trace)
    elif args.alg == 'LS1':
        # Run first local search (Hill Climbing)
        solution, solution_indices, trace = hill_climbing(U, S, subset_indices, 
                                                         max_iterations=1000000,  # Large value, will be limited by time
                                                         seed=args.seed,
                                                         cutoff_time=args.time)  # need to add this parameter
        write_output(args.inst, args.alg, args.time, args.seed, solution_indices, trace)
    elif args.alg == 'LS2':
        # Run second local search (e.g., Simulated Annealing)
        pass

if __name__ == "__main__":
    main()

